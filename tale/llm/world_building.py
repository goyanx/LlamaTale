
import json
import random
from tale import parse_utils
from tale import zone
from tale.base import Location
from tale.coord import Coord
from tale.llm.llm_ext import DynamicStory
from tale.llm.llm_io import IoUtil
from tale.llm.requests.build_location import BuildLocation
from tale.llm.requests.generate_zone import GenerateZone
from tale.zone import Zone


class WorldBuilding():

    def __init__(self, spawn_prompt: str, 
                 items_prompt: str, 
                 location_prompt: str, 
                 zone_prompt: str, 
                 story_background_prompt: str, 
                 start_location_prompt: str, 
                 io_util,
                 default_body: dict,
                 pre_json_prompt: str,
                 json_grammar: str,
                 backend: str = 'kobold_cpp'):
        self.spawn_prompt = spawn_prompt
        self.items_prompt = items_prompt
        self.location_prompt = location_prompt
        self.zone_prompt = zone_prompt
        self.story_background_prompt = story_background_prompt
        self.start_location_prompt = start_location_prompt
        self.backend = backend
        self.io_util = io_util # type: IoUtil
        self.default_body = default_body
        self.pre_json_prompt = pre_json_prompt
        self.json_grammar = json_grammar
        self.__story = None


    def build_location(self, location: Location, exit_location_name: str, zone_info: dict):
        """ Generate a location based on the current story context"""
        

        prompt = BuildLocation().build_prompt({
            'zone_info': zone_info,
            'location': location,
            'exit_location_name': exit_location_name,
            'story_type': self.__story.config.type,
            'world_info': self.__story.config.world_info,
            'story_context': self.__story.config.context,
        })

        request_body = self.default_body
        if self.backend == 'kobold_cpp':
            request_body = self._kobold_generation_prompt(request_body)

        result = self.io_util.synchronous_request(request_body, prompt=prompt)
        try:
            json_result = json.loads(parse_utils.sanitize_json(result))
            return self.validate_location(json_result, location, exit_location_name)
        except json.JSONDecodeError as exc:
            print(exc)
            return None, None
        except Exception as exc:
            return None, None
        
    def validate_location(self, json_result: dict, location_to_build: Location, exit_location_name: str):
        """Validate the location generated by LLM and update the location object."""
        try:
            # start locations have description already, and we don't want to overwrite it
            if not location_to_build.description:
                description = json_result.get('description', '')
                if not description:
                    # this is a hack to get around that it sometimes generate an extra json layer
                    json_result = json_result[location_to_build.name]
                location_to_build.description = json_result['description']

            items = parse_utils.load_items(json_result.get("items", []))
            # the loading function works differently and will not insert the items into the location
            # since the item doesn't have the location
            
            for item in items.values():
                location_to_build.insert(item, None)

            npcs = parse_utils.load_npcs(json_result.get("npcs", []))
            for npc in npcs.values():
                location_to_build.insert(npc, None)

            new_locations, exits = parse_utils.parse_generated_exits(json_result, 
                                                                     exit_location_name, 
                                                                     location_to_build)
            location_to_build.built = True
            return new_locations, exits
        except Exception as exc:
            print(f'Exception while parsing location {json_result} ')
            print(exc)
            return None, None
            
    
    def get_neighbor_or_generate_zone(self, current_zone: Zone, current_location: Location, target_location: Location) -> Zone:
        """ Check if the target location is on the edge of the current zone. If not, will return the current zone.
        If it is, will check if there is a neighbor zone in the direction of the target location. If not, will
        generate a new zone in that direction."""

        direction = target_location.world_location.subtract(current_location.world_location)
        on_edge = current_zone.on_edge(current_location.world_location, direction)
        if on_edge:
            neighbor = current_zone.get_neighbor(direction)
            if neighbor:
                return neighbor
            else:
                for i in range(5):
                    json_result = self.generate_zone(location_desc=target_location.description, 
                                        exit_location_name=current_location.name, 
                                        current_zone_info=current_zone.get_info(),
                                        direction=parse_utils.direction_from_coordinates(direction))
                    if json_result:
                        zone = self.validate_zone(json_result, 
                                                  target_location.world_location.add(
                                                      direction.multiply(json_result.get('size', 5))))
                        if zone:
                            if self.__story.add_zone(zone):
                                return zone
        return current_zone

        
    def generate_zone(self, location_desc: str, exit_location_name: str = '', current_zone_info: dict = {}, direction: str = '') -> dict:
        """ Generate a zone based on the current story context"""
        prompt = GenerateZone(self.pre_json_prompt, self.zone_prompt).build_prompt({
            'direction': direction,
            'current_zone_info': current_zone_info,
            'exit_location_name': exit_location_name,
            'location_desc': location_desc,
            'story_type': self.__story.config.type,
            'world_info': self.__story.config.world_info,
            'world_mood': self.__story.config.world_mood,
            'story_context': self.__story.config.context,
        })
        
        request_body = self.default_body
        if self.backend == 'kobold_cpp':
            request_body = self._kobold_generation_prompt(request_body)
        
        request_body['max_length'] = 750
        result = self.io_util.synchronous_request(request_body, prompt=prompt)
        try:
            json_result = json.loads(parse_utils.sanitize_json(result))
            return json_result
        except json.JSONDecodeError as exc:
            print(exc)
            return None

    def validate_zone(self, json_result: dict, center: Coord) -> Zone:
        """Create the Zone object."""
        zone = Zone(name=json_result['name'], description=json_result['description'])
        zone.level = json_result.get('level', 1)
        zone.mood = json_result.get('mood', 0)
        zone.center = center
        zone.size = json_result.get('size', 5)
        zone.races = json_result.get('races', [])
        zone.items = json_result.get('items', [])
        return zone
    
    def generate_story_background(self, world_mood: int, world_info: str):
        prompt = self.story_background_prompt.format(
            story_type=self.__story.config.type,
            world_mood=parse_utils.mood_string_from_int(world_mood),
            world_info=world_info)
        request_body = self.default_body
        if self.backend == 'kobold_cpp':
            request_body['prompt'] = prompt
        elif self.backend == 'openai':
            request_body['messages'][1]['content'] = prompt
        return self.io_util.synchronous_request(request_body)
        
    def generate_start_location(self, location: Location, zone_info: dict, story_type: str, story_context: str, world_info: str):
        """ Generate a location based on the current story context
        One gotcha is that the location is not returned, its contents are just updated"""

        items_prompt = ''
        item_amount = random.randint(0, 2)
        if item_amount > 0:
            items_prompt = self.items_prompt.format(items=item_amount)

        prompt = self.pre_json_prompt
        prompt += self.start_location_prompt.format(
            story_type=story_type,
            world_info=world_info,
            location_description=location.description,
            spawn_prompt='',
            item_prompt='',
            zone_info=zone_info,
            story_context=story_context,
            items_prompt=items_prompt)
        
        request_body = self.default_body
        if self.backend == 'kobold_cpp':
            request_body = self._kobold_generation_prompt(request_body)
            request_body['prompt'] = prompt
        elif self.backend == 'openai':
            request_body['messages'][1]['content'] = prompt
        result = self.io_util.synchronous_request(request_body)
        try:
            json_result = json.loads(parse_utils.sanitize_json(result))
            location.name=json_result['name']
            return self.validate_location(json_result, location, '')
        except json.JSONDecodeError as exc:
            print(exc)
            return None, None
        except Exception as exc:
            return None, None
        
    def generate_start_zone(self, location_desc: str, story_type: str, story_context: str, world_mood: int, world_info: str) -> Zone:
        """ Generate a zone based on the current story context"""
        prompt = self.pre_json_prompt
        prompt += self.zone_prompt.format(
            world_info=world_info,
            mood = parse_utils.mood_string_from_int(random.gauss(world_mood, 2)),
            story_type=story_type,
            direction='',
            zone_info='',
            story_context=story_context,
            exit_location='',
            location_desc=location_desc)
        
        request_body = self.default_body
        if self.backend == 'kobold_cpp':
            request_body = self._kobold_generation_prompt(request_body)
            request_body['prompt'] = prompt
        elif self.backend == 'openai':
            request_body['messages'][1]['content'] = prompt
        request_body['max_length'] = 750
        result = self.io_util.synchronous_request(request_body)
        try:
            json_result = json.loads(parse_utils.sanitize_json(result))
            return zone.from_json(json_result)
        except json.JSONDecodeError as exc:
            print(exc)
            return None
        
    def _kobold_generation_prompt(self, request_body: dict) -> dict:
        """ changes some parameters for better generation of locations in kobold_cpp"""
        request_body = request_body.copy()
        request_body['stop_sequence'] = ['\n\n']
        request_body['temperature'] = 0.5
        request_body['top_p'] = 0.6
        request_body['top_k'] = 0
        request_body['rep_pen'] = 1.0
        request_body['grammar'] = self.json_grammar
        #request_body['banned_tokens'] = ['```']
        return request_body
    
    def set_story(self, story: DynamicStory):
        self.__story = story